A /B /V1/V2/V3/V4

A1/B1/6 /2 /3 /5
A1/B1/4 /3 /1 /2
A1/B2/9 /3 /4 /3

compute = 3/1

valueSeries
0: value(1);count
1: computed(3,1)
2: value(2);sum

   B1      B2    T
A1 2;1,4;4 1;3;4 3;1,25;8
T  2;1,4;4 1;3;4 3;1,25;8

   B1                    B2                    T
   c(V2) computed1 s(V3) c(V2) computed1 s(V3) c(V2) computed1 s(V3)
A1 2     1,4       4     1     3         4     3     1,25      8
T  2     1,4       4     1     3         4     3     1,25      8

indexes to ensure indexes are used only once (computed need to be read but we can accept several declaration in this case)
1 => visible0 [computed1]
3 => computed1
2 => visible1

row.col.cell[0]=row.col.cell[0]+record[1]
row.col.cell[0]=row.col.cell[0]+record[1]

collect all needed values from record:
valueSeries[0,1,2] ==> map[1,3,2]{true, true, true} ==> [1,3,2] ==> map[1,3,2]{record[1],record[3],record[2]}
valueSeries[0,1,2] && compute==nil = valueSeries[0,2] ==> [1,2] ==> row.col.cell[0,2]=row.col.cell[0,2]+record[1,2]
valueSeries[0,1,2] && compute!=nil = valueSeries[1] ==>

cell {
    value map[index]float64

}